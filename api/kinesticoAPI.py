import uuid
from flask import Blueprint, request, jsonify
from firebase_admin import firestore

db = firestore.client()
user_Ref = db.collection('user')

kinesticoAPI = Blueprint('kinestico', __name__)

@kinesticoAPI.route('/list/kinestesico')
def tiposdatos():
    try:
        urlYoutube = [
            {
                "temas": "Variables y Tipos de datos",
                "contenido": [
                    {
                        "titulo": "Variables y Tipos de datos",
                        "url": "Variables <br><br> ¿Qué es? <br><br> Es un espacio en memoria en el cual se almacena información que deseamos almacenar de manera temporal, a la cual podremos acceder y modificar en cualquier momento que lo necesitemos en el tiempo de ejecución de nuestro código. <br><br> ¿Cómo declarar una variable en python? <br><br> Declarar una variable en Python es muy sencillo, solo falta con poner el nombre de nuestra variable seguido de un signo de igualdad (=), y al finalizar asignarle un valor a la misma. <br><br> Ejemplo: <br><br> Guardamos en la variable suma el resultado de la operación 1 + 2 <br><br> suma = 1 + 2 <br><br> Datos primitivos simples y compuesto <br><br> Los tipos de datos primitivos y compuestos en python son las estructuras de datos elementales del lenguaje de programación. Son los componentes básicos para tratar todo tipo de datos o variables y contienen valores de datos puros y simples. <br><br> Tipos de datos primitivos simples <br><br> Números (numbers): Secuencia de dígitos (pueden incluir el - para negativos y el . para decimales) que representan números. <br><br>Ejemplo. 0, -1, 3.1415. <br><br> Cadenas (strings): Secuencia de caracteres alfanuméricos que representan texto. Se escriben entre comillas simples o dobles. <br><br>Ejemplo. ‘Hola’, “Adiós”. <br><br> Booleanos (boolean): Contiene únicamente dos elementos True y False que representan los valores lógicos verdadero y falso respectivamente. <br><br>Estos datos son inmutables, es decir, su valor es constante y no puede cambiar. <br><br>Tipos de datos primitivos compuestos (contenedores) <br><br>Listas (lists): Colecciones de objetos que representan secuencias ordenadas de objetos de distintos tipos. Se representan con corchetes y los elementos se separan por comas. <br><br> Ejemplo. [1, “dos”, [3, 4], True]. <br><br> Tuplas (tuples). Colecciones de objetos que representan secuencias ordenadas de objetos de distintos tipos. A diferencia de las listas son inmutables, es decir, que no cambian durante la ejecución. Se representan mediante paréntesis y los elementos se separan por comas. <br><br>Ejemplo. (1, ‘dos’, 3) <br><br> Diccionarios (dictionaries): Colecciones de objetos con una clave asociada. Se representan con llaves, los pares separados por comas y cada par contiene una clave y un objeto asociado separados por dos puntos. <br><br>Ejemplo. {‘pi’:3.1416, ’e’:2.718}."
                    }
                ]
            },
            {
                "temas": "Estructuras de decisión",
                "contenido": [
                    {
                        "titulo": "Estructuras de decisión - Sentencia If",
                        "url": "Estructura de decisión  <br><br>Una estructura de decisión permite que la ejecución de un algoritmo tome distintos caminos, que llevan a distintos resultados, dependiendo de la condición o condiciones presentes en la estructura de decisión.  <br><br>Sentencia if  <br><br> Una sentencia if en Python evalúa una condición y si esta resulta ser verdadera (True), entonces ejecuta una vez el código en la expresión. Si sucede el caso contrario y la expresión es falsa, entonces No ejecutes el código que sigue.  <br><br>La sintaxis general para la sentencia if  es la siguiente  <br><br>if condicion:  <br><br> ejecutar sentencia  <br><br>Operadores de comparación  <br><br>Ahora bien, antes de dar un ejemplo de manera formal debemos hablar de los operadores de comparación, estos se utilizan, como su nombre indica, para comparar dos o más valores. El resultado de estos operadores siempre es True o False  <br><br>En Python tenemos los siguientes operadores de comparación   <br><br><img src='https://firebasestorage.googleapis.com/v0/b/adapprogram-704ac.appspot.com/o/Operadores%20de%20comparacion%20.png?alt=media&token=739589ed-ac95-40e9-9831-dd3767aab0ab'> <br><br>ext(Ejemplos de sentencia if con operadores de comparación  <br><br>Ejemplo 1:  <br><br>if 2<3:  <br><br> print(“2 es menor que 3”)  <br><br>Ejemplo 2:  <br><br>if 2<=2:  <br><br>     print(“2 es menor o igual que 2”)  <br><br>Ejemplo 3:  <br><br>if 22>20:  <br><br>  print(“23  es mayor que 20”)  <br><br>Ejemplo 4:  <br><br>if 22>=22:  <br><br>     print(“22 es mayor o igual que 2”)  <br><br>Ejemplo 5:  <br><br>if 45==45:  <br><br>     print(“45 es igual que 45”)  <br><br>Ejemplo 6:  <br><br>if 45 ¡= 50:  <br><br>     print(“45 es diferente que 50”)  <br><br>)",
                    },
                    {
                        "titulo": "Estructuras de decisión - Sentencia If....else",
                        "url": "Estructura de decisión /nSentencia if…else/nCómo mencionamos, una sentencia if ejecuta el código, solo en caso de cumplirse la condición, pero ¿qué sucede si queremos ejecutar un código alternativo en caso de no cumplirse la condición? Es en este caso es necesario usar una sentencia if..else. La cual nos permite que cuando la expresión if se evalúa como True, entonces ejecuta el código que le sigue. Pero si se evalúa como False, entonces ejecuta el código que sigue después de la sentencia else. La sentencia else está escrita en una nueva línea, posterior a la última línea del código indentado, y no puede ser escrita por sí misma. Una sentencia else tiene como prerrequisito una sentencia if, siendo a la vez, parte de él. /nLa sintaxis de una sentencia if..else es parecida a la siguiente: /nif condicion: /n    ejecutar codigo si la condicion es True/nelse: /n     ejecutar codigo si la condicion es False/nEjemplo de sentencia if….else/nNos piden un programa el cual permita determinar si una persona es mayor edad/nedadMin = 18/nprint(“Ingrese su edad”) /nedadCustomer = int(input())/nif edadCustomer >= edadMin : /n	print(“Es mayor de edad”) /nelse: /n	print(“Es menor de edad”) /nAl momento de ejecutar este código puede ocurrir 2 casos, en el caso de que la sentencia if sea verdadera se nos imprimirá en pantalla el mensaje de “Es mayor de edad” y en el caso de que la edad no sea la mínima se imprimirá en pantalla ''Es menor de edad'."
                    },
                    {
                        "titulo": "Estructuras de decisión - Sentencia If....elif.....else",
                        "url": "Estructura de decisión  <br><br>Sentencia if…else <br><br>Cómo mencionamos, una sentencia if ejecuta el código, solo en caso de cumplirse la condición, pero ¿qué sucede si queremos ejecutar un código alternativo en caso de no cumplirse la condición? Es en este caso es necesario usar una sentencia if..else. La cual nos permite que cuando la expresión if se evalúa como True, entonces ejecuta el código que le sigue. Pero si se evalúa como False, entonces ejecuta el código que sigue después de la sentencia else. La sentencia else está escrita en una nueva línea, posterior a la última línea del código indentado, y no puede ser escrita por sí misma. Una sentencia else tiene como prerrequisito una sentencia if, siendo a la vez, parte de él.  <br><br>La sintaxis de una sentencia if..else es parecida a la siguiente:  <br><br>if condicion:  <br><br> ejecutar codigo si la condicion es True <br><br>else:  <br><br>ejecutar codigo si la condicion es False <br><br>Ejemplo de sentencia if….else  <br><br>Nos piden un programa el cual permita determinar si una persona es mayor edad <br><br>edadMin = 18 <br><br>print(“Ingrese su edad”)  <br><br>edadCustomer = int(input()) <br><br>if edadCustomer >= edadMin :  <br><br>print(“Es mayor de edad”)  <br><br>else:  <br><br>print(“Es menor de edad”)  <br><br>Al momento de ejecutar este código puede ocurrir 2 casos, en el caso de que la sentencia if sea verdadera se nos imprimirá en pantalla el mensaje de “Es mayor de edad” y en el caso de que la edad no sea la mínima se imprimirá en pantalla “Es menor de edad”.  <br><br>"
                    },
                    {
                        "titulo": "Estructuras de decisión - if ternario",
                        "url": "Estructura de decisión  <br><br>If ternario  <br><br>El operador ternario en Python, al igual que en otros lenguajes, tiene la finalidad de hacer más compacta una condición If, permitiendo generar código condicionado en una sola línea y aunque no es ampliamente usado sí que tiene sus ventajas.  <br><br>La sintaxis de if ternario <br><br>condition_if_true if condition else condition_if_false <br><br>esta sintaxis de if ternario tiene una particularidad y es que primero escribimos las instrucciones que se ejecutaran si nuestra condición es verdadera, seguido de la sentencia if y nuestra condición, luego pondremos nuestra sentencia else seguido de las instrucciones que se ejecutaran en el caso que if sea falso.  <br><br>ejemplo de if ternario <br><br>es_bonito = True <br><br>print('Es bonito')  if es_bonito else print('No es bonito') <br><br>resultado  <br><br>“Es bonito”  <br><br>Como se puede ver, permiten verificar de manera rápida una condición, y lo mejor de todo es que se puede hacer en una sola línea de código. Por lo general hacen que el código sea más compacto y fácil de leer.  <br><br>Otra forma un tanto extraña y no demasiado usada es la siguiente forma:  <br><br>La sintaxis de if ternario 2 <br><br>(if_test_is_false, if_test_is_true)[test]  <br><br>ejemplo de if ternario 2 <br><br>es_bonito = True <br><br>apariencia = ('Feo', 'Bonito')[es_bonito]  <br><br>retultado <br><br>print('El gato es', apariencia)  <br><br>Este ejemplo funciona ya que True=1 y False=0, y puede ser usado también con listas. Es importante decir también que este ejemplo no es muy usado."
                    },
                ]
            },            
            {
                "temas": "Estructuras iterativas",
                "contenido": [
                    {
                        "titulo": "Estructuras iterativas - Sentencia while loop Part 1",
                        "url": "Estructuras iterativas  <br><br>Bucle while loop <br><br> A diferencia de las estructuras de decisión, las iterativas nos permiten ejecutar un mismo código, de manera repetida, mientras se cumpla una condición.  <br><br>while loop repite la secuencia de acciones muchas veces hasta que alguna condición se evalúa como False. La condición se da antes del cuerpo del bucle y se comprueba antes de cada ejecución del cuerpo del bucle. Típicamente, el while se utiliza bucle cuando es imposible para determinar el número exacto de iteraciones del bucle de antemano.  <br><br>Estructura de while loop  <br><br>while some condition:  <br><br>    a block of statements <br><br>Ejemplo de while loop <br><br>anio = 2001  <br><br>while anio <= 2012:  <br><br>    print ('Informes del Año', anio)  <br><br>    anio += 1 <br><br>Resultado <br><br>Informes del año 2001  <br><br>Informes del año 2002  <br><br>Informes del año 2003  <br><br>Informes del año 2004  <br><br>Informes del año 2005  <br><br>Informes del año 2006  <br><br>Informes del año 2007  <br><br>Informes del año 2008  <br><br>Informes del año 2009  <br><br>Informes del año 2010  <br><br>Informes del año 2011  <br><br>Informes del año 2012 <br><br>Si miramos la última línea:  <br><br>anio += 1 <br><br>se puede notar que en cada iteración, incrementamos el valor de la variable que condiciona el bucle (anio). Si no lo hiciéramos, esta variable siempre sería igual a 2001 y el bucle se ejecutaría de forma infinita, ya que la condición (anio <= 2012) siempre se estaría cumpliendo."
                    },
                    {
                        "titulo": "Estructuras iterativas - Sentencia while loop Part 2",
                        "url": "Estructuras iterativas <br><br>Bucle while loop uso de break y continue <br><br>break <br><br>¿Qué sucede si el valor que condiciona la iteración no es numérico y no puede incrementarse? En ese caso, podremos utilizar una estructura de control condicional, anidada dentro del bucle, y frenar la ejecución cuando el condicional deje de cumplirse, con la palabra clave reservada break:  <br><br>while True:  <br><br>    nombre = raw_input('Indique su nombre: ') <br><br>   if nombre:  <br><br>        break <br><br> El bucle anterior, incluye un condicional anidado que verifica si la variable nombre es verdadera (solo será verdadera si el usuario tipea un texto en pantalla cuando el nombre le es solicitado). Si es verdadera, el bucle para (break). Si no, seguirá ejecutándose hasta que el usuario, ingrese un texto en pantalla.  <br><br>Continue <br><br> La instrucción Continue en Python devuelve la ejecución al comienzo del ciclo while. La declaración de Continue rechaza todas las declaraciones restantes en la iteración actual del bucle y mueve el control de nuevo a la parte superior del bucle.  <br><br>Ejemplo de continue en ciclo while loop <br><br>var = 10  <br><br>while var > 0:  <br><br>   var = var -1 <br><br>   if var == 5:  <br><br>      continue <br><br>   print ('valor de la variable:', var)  <br><br>Resultado <br><br>valor de la variable :10 <br><br>valor de la variable: 9 <br><br>valor de la variable: 8 <br><br>valor de la variable: 7 <br><br>valor de la variable: 6 <br><br>valor de la variable: 4  <br><br>valor de la variable: 3 <br><br>valor de la variable: 2 <br><br>valor de la variable: 1 <br><br>"
                    },
                    {
                        "titulo": "Estructuras iterativas - Sentencia For loop",
                        "url": "Estructuras iterativas <br><br>Bucle foor loop <br><br>El ciclo for loop en Python se usa para iterar sobre una secuencia ( lista , tupla , cadena ) u otros objetos iterables. La iteración sobre una secuencia se llama recorrido.  <br><br>Estructura de bucle foor loop <br><br>for val in sequence:  <br><br>    loop body <br><br>Aquí val es la variable que toma el valor del elemento dentro de la secuencia en cada iteración. El bucle continúa hasta que llegamos al último elemento de la secuencia. El cuerpo del bucle for se separa del resto del código mediante sangría.  <br><br>Ejemplos de bucle foor loop <br><br>numbers = [6, 5, 3, 8, 4, 2, 5, 4, 11]  <br><br>sum = 0 <br><br>for val in numbers:  <br><br>    sum = sum+val <br><br>print('El total de la suma es', sum)  <br><br>Resultado <br><br>la suma es 48 <br><br>"              
                    },
                    {
                        "titulo": "Estructuras iterativas - Sentencia For loop range()",
                        "url": "Estructuras iterativas  <br><br>Bucle foor loop uso de función range() <br><br>Podemos generar una secuencia de números usando range()la función. range(10)generará números del 0 al 9 (10 números). También podemos definir el tamaño de inicio, parada y paso como range(start, stop,step_size). step_size por defecto es 1 si no se proporciona. Esta función no almacena todos los valores en la memoria; sería ineficiente. Por lo tanto, recuerda el inicio, la parada, el tamaño del paso y genera el siguiente número sobre la marcha.  <br><br>Podemos usar la función range()en bucles  for para iterar a través de una secuencia de números. Se puede combinar con la función len() para iterar a través de una secuencia usando la indexación. Aquí hay un ejemplo.  <br><br>Ejemplo de for loop con función range() <br><br>genre = ['pop', 'rock', 'jazz']  <br><br>for i in range(len(genre)):  <br><br>    print(´'Me gusta el ', genre[i])  <br><br>Resultado  <br><br>Me gusta el pop <br><br>Me gusta el rock <br><br>Me gusta el jazz <br><br>"
                    },
                    {
                        "titulo": "Estructuras iterativas - Sentencia For loop anidados",
                        "url": "Estructuras iterativas <br><br>Bucle foor loop anidado <br><br>Se habla de bucles anidados cuando un bucle se encuentra en el bloque de instrucciones de otro bloque. Al bucle que se encuentra dentro del otro se le puede denominar bucle interior o bucle interno. El otro bucle sería el bucle exterior o bucle externo. Los bucles pueden tener cualquier nivel de anidamiento (un bucle dentro de otro bucle dentro de un tercero, etc.).  <br><br>Bucle foor loop anidado (variables independientes)  <br><br>Se dice que las variables de los bucles son independientes cuando los valores que toma la variable de control del bucle interno no dependen del valor de la variable de control del bucle externo.  <br><br>Ejemplo de bucle foor loop 1 <br><br>for i in [0, 1, 2]:  <br><br>    for j in [0, 1]:  <br><br>        print(f'i vale {i} y j vale {j}') <br><br>resultado <br><br>i vale 0 y j vale 0 <br><br>i vale 0 y j vale 1 <br><br>i vale 1 y j vale 0 <br><br>i vale 1 y j vale 1 <br><br>i vale 2 y j vale 0 <br><br>i vale 2 y j vale 1 <br><br>En el ejemplo anterior, el bucle externo (el controlado por i) se ejecuta 3 veces y el bucle interno (el controlado por j) se ejecuta dos veces por cada valor de i. Por ello la instrucción print() se ejecuta en total 6 veces (3 veces que se ejecuta el bucle externo x 2 veces que se ejecuta cada vez el bucle interno = 6 veces). En general, el número de veces que se ejecuta el bloque de instrucciones del bucle interno es el producto de las veces que se ejecuta cada bucle.  <br><br>Ejemplo de bucle foor loop 2 <br><br>factoresX = [1,2,3,4,5]  <br><br>factoresY = [1,2,3,4,5]  <br><br>for factorX in factoresX:  <br><br>  for factorY in factoresY:  <br><br>print(f'{factorX} x {factorY} = {factorX * factorY}') <br><br>resultado  <br><br>1 x 1 = 1 <br><br>1 x 2 = 2 <br><br>1 x 3 = 3 <br><br>1 x 4 = 4 <br><br>1 x 5 = 5 <br><br>2 x 1 = 2 <br><br>2 x 2 = 4 <br><br>2 x 3 = 6 <br><br>2 x 4 = 8 <br><br>2 x 5 = 10 <br><br>3 x 1 = 3 <br><br>3 x 2 = 6 <br><br>3 x 3 = 9 <br><br>3 x 4 = 12 <br><br>3 x 5 = 15 <br><br>4 x 1 = 4 <br><br>4 x 2 = 8 <br><br>4 x 3 = 12 <br><br>4 x 4 = 16 <br><br>4 x 5 = 20 <br><br>5 x 1 = 5 <br><br>5 x 2 = 10 <br><br>5 x 3 = 15 <br><br>5 x 4 = 20 <br><br>5 x 5 = 25 <br><br>"
                    },
                ]
            },
            {
                "temas": "Funciones iterativas",
                "contenido": [
                    {
                        "titulo": "Funciones iterativas - Definición de función",
                        "url": "Funciones  <br><br>Definición de funciones en Python  <br><br>Las funciones son bloques de código que se pueden reutilizar simplemente llamando a la función. Esto permite la reutilización de código simple y elegante sin volver a escribir explícitamente secciones de código. Esto hace que el código sea más legible, facilita la depuración y limita los errores de escritura.  <br><br>Estructura de una función <br><br>def functionName():  <br><br>    code block <br><br>Ejemplo <br><br>def saludo(): <br><br>	print(“hola mundo”)  <br><br>saludo() <br><br>Resultado  <br><br>hola mundo"
                    },
                    {
                        "titulo": "Funciones iterativas - Argumentos de una función",
                        "url": "Funciones  <br><br>Argumentos en funciones  <br><br>Un argumento es un valor que la función espera recibir cuando sea llamada, a fin de ejecutar acciones en base al mismo. Una función puede esperar uno o más parámetros, los cuales irán separados por una coma.  <br><br>Ejemplo Argumentos 1 <br><br>def saludo(nombre, apellido):  <br><br>    print(f'hola {nombre} {apellido}') <br><br>saludo('steven', 'otalvaro')  <br><br>Resultado  <br><br>Hola Steven otalvaro <br><br>Ahora bien, podemos setear los valores de los parámetros con el fin que el orden no importe, y de esta manera cuando nuestra función reciba los argumentos, los reciba de manera correcta, en el ejemplo anterior vimos como pasar argumentos a la función, ahora lo que haremos será setear los parámetros cuando se envían en la función y para esto, lo que deberos hacer es ponerle a cada nombre del parámetro el valor que este tendrá <br><br>Ejemplo <br><br>def saludo(nombre, apellido):  <br><br>    print(f'hola {nombre} {apellido}') <br><br>saludo(apellido='otalvaro', nombre='steven')  <br><br>Resultado  <br><br>Hola Steven otalvaro <br><br>Vemos que cuando llamamos a la función le indicamos el valor que tendrá cada argumento y de esta manera el orden de los argumentos no importará.  <br><br>"
                    },
                    {
                        "titulo": "Funciones iterativas - Argumentos de una función de tipo args y kwargs",
                        "url": "Funciones <br><br>Argumentos args y kwargs <br><br>Existen dos tipos de argumentos en Python, los convencionales y aquellos que están sujetos a un nombre específico, generalmente identificados como args (arguments) y kwargs (keyword arguments), respectivamente. Encontrar un término en el español para estos últimos resulta algo complejo, equivaldría a argumentos de palabras clave, así que simplemente los llamaremos por su nombre original.  <br><br>Una de las principales diferencias entre los dos tipos de argumentos, como observamos anteriormente, es que los convencionales son posicionales, mientras que en los keyword arguments su ubicación es indistinta.  <br><br>Ejemplo de args <br><br>def suma(*args):  <br><br>    resultado = 0 <br><br>    for num in args:  <br><br>        resultado += num <br><br>    print(resultado)  <br><br>suma(1, 2, 3)  <br><br>Resultado  <br><br>6 <br><br>Ejemplo de kwargs <br><br>def concatenacion(**kwargs):  <br><br>    resultado = "" <br><br>    for arg in kwargs.values(): <br><br>        resultado += ' ' + arg <br><br>    print(resultado)concatenacion(a='python', b='es', c='un', d='lenguaje', e='de',f='programacion') <br><br>Resultado <br><br>python es un lenguaje de programacion",
                    }
                    ,
                    {
                        "titulo": "Funciones iterativas - Sentencia return en funciones",
                        "url": "Funciones  <br><br>Return  <br><br> Se utiliza una declaración de return para finalizar la ejecución de la llamada de función y devuelve el resultado (el valor de la expresión que sigue a la palabra clave return) . Las sentencias posteriores a las sentencias de retorno no se ejecutan. Si la declaración de devolución no tiene ninguna expresión, se devuelve el valor especial Ninguno. Una declaración de retorno se usa en general para invocar una función para que las declaraciones pasadas puedan ejecutarse.  <br><br>Syntax:  <br><br>def fun(): <br><br>    statements <br><br>    return [expression]  <br><br>ejemplo  <br><br>def suma(*args):  <br><br>	resultado = 0 <br><br> 	for num in args:  <br><br>		resultado += num <br><br>	return resultado <br><br>print(suma(1,2,3,4,5,6))",
                    }
                ]
            },
        ]
        return jsonify(urlYoutube), 200
    except Exception as e:
        return f"an error ocurred : {e}"